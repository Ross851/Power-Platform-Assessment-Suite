import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle,
  Footer,
  AlignmentType,
} from "docx"
import saveAs from "file-saver"
import type { Project, Question, Evidence } from "./types"
import { format } from "date-fns"

// --- Helper Functions ---
const sanitizeFilename = (name: string) => name.replace(/[^a-zA-Z0-9-]/g, "_")

const createHeading = (text: string, level: HeadingLevel = HeadingLevel.HEADING_1) =>
  new Paragraph({ heading: level, children: [new TextRun({ text, bold: true })] })

const createSubHeading = (text: string, level: HeadingLevel = HeadingLevel.HEADING_2) =>
  new Paragraph({
    heading: level,
    children: [new TextRun({ text, bold: true })],
  })

const createParagraph = (text: string) => new Paragraph(text)

const createBullet = (text: string, level = 0) => new Paragraph({ text, bullet: { level } })

const createCell = (text: string, bold = false) =>
  new TableCell({
    children: [new Paragraph({ children: [new TextRun({ text, bold })] })],
    margins: { top: 100, bottom: 100, left: 100, right: 100 },
  })

const createStyledTable = (rows: TableRow[]) =>
  new Table({
    rows,
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: {
      top: { style: BorderStyle.SINGLE, size: 1, color: "D3D3D3" },
      bottom: { style: BorderStyle.SINGLE, size: 1, color: "D3D3D3" },
      left: { style: BorderStyle.SINGLE, size: 1, color: "D3D3D3" },
      right: { style: BorderStyle.SINGLE, size: 1, color: "D3D3D3" },
      insideH: { style: BorderStyle.SINGLE, size: 1, color: "D3D3D3" },
      insideV: { style: BorderStyle.SINGLE, size: 1, color: "D3D3D3" },
    },
  })

const createDocumentWithBranding = (children: any[]) => {
  return new Document({
    footers: {
      default: new Footer({
        children: [
          new Paragraph({
            alignment: AlignmentType.CENTER,
            children: [
              new TextRun({
                text: "Confidential | Generated by Telana",
                size: 16, // 8pt
                color: "808080",
              }),
            ],
          }),
        ],
      }),
    },
    sections: [{ children }],
  })
}

// --- Client-Facing C-Suite Document Generator ---
export const exportToClientWord = async (project: Project) => {
  const highPriorityAreas = getHighPriorityAreas(project)

  const doc = createDocumentWithBranding([
    createHeading(`Telana Power Platform Assessment: Executive Summary`),
    createSubHeading(project.name),
    createParagraph(`Date: ${format(new Date(), "dd MMMM yyyy")}`),
    createParagraph(`Client Reference: ${project.clientReferenceNumber || "N/A"}`),
    new Paragraph({ text: "" }), // Spacer

    createSubHeading("1. Key Findings & Strategic Recommendations"),
    createParagraph(
      "This assessment has identified several key areas for improvement that will enhance security, streamline governance, and unlock greater value from your Power Platform investment. The following recommendations are prioritised based on business impact and risk mitigation.",
    ),
    ...highPriorityAreas.slice(0, 5).flatMap((area) => [
      new Paragraph({
        children: [
          new TextRun({ text: `Recommendation for ${area.standardName}: `, bold: true }),
          new TextRun(`Address critical gaps identified in '${area.questionText || "overall standard"}'.`),
        ],
      }),
      createBullet(
        `Impact: Mitigates ${area.ragStatus === "red" ? "high" : "medium"} risk related to ${area.category}.`,
      ),
      createBullet(`Assigned Owner (Recommended): ${area.riskOwner || "To be assigned"}`),
      new Paragraph(""),
    ]),

    createSubHeading("2. High-Priority Risk Register"),
    createParagraph(
      "The following table outlines the most critical risks identified during the assessment that require immediate attention.",
    ),
    createStyledTable([
      new TableRow({
        children: [
          createCell("Area", true),
          createCell("Risk / Issue", true),
          createCell("Status", true),
          createCell("Owner", true),
        ],
        tableHeader: true,
      }),
      ...highPriorityAreas.map(
        (area) =>
          new TableRow({
            children: [
              createCell(area.standardName),
              createCell(area.questionText || "Overall standard weakness"),
              createCell(area.ragStatus.toUpperCase()),
              createCell(area.riskOwner || "TBA"),
            ],
          }),
      ),
    ]),
    new Paragraph({ text: "" }),

    createSubHeading("3. Strategic Roadmap Overview"),
    createParagraph(
      "We recommend a phased approach to address these findings, focusing on foundational improvements first, followed by optimisation and innovation.",
    ),
    createStyledTable([
      new TableRow({
        children: [createCell("Phase", true), createCell("Timeline", true), createCell("Focus Areas", true)],
        tableHeader: true,
      }),
      new TableRow({
        children: [
          createCell("Phase 1: Foundation"),
          createCell("0-3 Months"),
          createCell("Address all 'Red' status risks. Solidify DLP policies and environment strategy."),
        ],
      }),
      new TableRow({
        children: [
          createCell("Phase 2: Optimisation"),
          createCell("3-6 Months"),
          createCell("Remediate 'Amber' status risks. Implement ALM automation and mature CoE processes."),
        ],
      }),
      new TableRow({
        children: [
          createCell("Phase 3: Innovation"),
          createCell("6-12 Months"),
          createCell(
            "Focus on technical debt reduction, modernisation of custom apps, and expanding Responsible AI governance.",
          ),
        ],
      }),
    ]),
    new Paragraph({ text: "" }),

    createSubHeading("4. Next Steps"),
    createParagraph(
      "We recommend a follow-up workshop to review these findings in detail and finalise the implementation plan and resource allocation. The accompanying technical document provides the detailed instructions for your development team.",
    ),
  ])

  const blob = await Packer.toBlob(doc)
  const today = format(new Date(), "yyyyMMdd")
  const projectName = sanitizeFilename(project.name)
  const refNumber = project.clientReferenceNumber ? sanitizeFilename(project.clientReferenceNumber) : "NO-REF"
  const fileName = `Telana_${today}_${projectName}_${refNumber}_Executive_Summary.docx`
  saveAs(blob, fileName)
}

// --- Technical Developer Document Generator ---
export const exportToTechnicalWord = async (project: Project) => {
  const allGaps = getAllGaps(project)

  const doc = createDocumentWithBranding([
    createHeading("Telana Power Platform Assessment: Technical Implementation Guide"),
    createSubHeading(project.name),
    createParagraph(`Generated on: ${format(new Date(), "dd MMMM yyyy")}`),
    createParagraph(`Client Reference: ${project.clientReferenceNumber || "N/A"}`),
    new Paragraph({ text: "" }),

    createSubHeading("1. Introduction"),
    createParagraph(
      "This document provides detailed, actionable instructions for the development and administration teams to remediate the findings from the Power Platform assessment. Each section corresponds to an identified gap.",
    ),
    new Paragraph({ text: "" }),

    createSubHeading("2. Scoring & Gap Analysis Explained", HeadingLevel.HEADING_2),
    createParagraph(
      "Our scoring model rates each assessment point on a scale of 1 to 5. This score determines the RAG (Red, Amber, Green) status and helps prioritise actions.",
    ),
    createBullet("Score 1-2 (Red Status): Indicates a significant gap and high risk. Urgent attention is required."),
    createBullet(
      "Score 3 (Amber Status): Represents a state of basic compliance. The foundational requirements are met, but there are clear opportunities for improvement.",
    ),
    createBullet(
      "Score 4-5 (Green Status): Shows strong alignment with Microsoft's best practices and a low-risk profile.",
    ),
    createParagraph("The gap analysis measures the difference between your current score and two key benchmarks:"),
    createBullet(
      "Gap to Basic Compliance: The difference between your score and the target score of 3. A value greater than zero here indicates a failure to meet baseline standards.",
    ),
    createBullet(
      "Gap to Gold Standard: The difference between your score and the maximum score of 5. This represents the effort required to achieve the highest level of maturity.",
    ),
    new Paragraph({ text: "" }),

    createSubHeading("3. Detailed Gap Analysis & Remediation Steps", HeadingLevel.HEADING_2),
    ...allGaps.flatMap((gap) => {
      const currentScore = gap.score || 0
      const gapToBasic = Math.max(0, 3 - currentScore)
      const gapToGold = Math.max(0, 5 - currentScore)

      return [
        createSubHeading(`Gap: ${gap.questionId} - ${gap.questionText}`, HeadingLevel.HEADING_3),
        createStyledTable([
          new TableRow({
            children: [createCell("Standard", true), createCell(gap.standardName)],
          }),
          new TableRow({
            children: [createCell("Category", true), createCell(gap.category)],
          }),
          new TableRow({
            children: [createCell("Status", true), createCell(gap.ragStatus.toUpperCase())],
          }),
          new TableRow({
            children: [createCell("Current Answer", true), createCell(JSON.stringify(gap.answer) || "N/A")],
          }),
          new TableRow({
            children: [createCell("Evidence Summary", true), createCell(gap.evidenceNotes || "None")],
          }),
        ]),
        new Paragraph({ text: "" }),
        new Paragraph({ children: [new TextRun({ text: "Quantitative Gap Analysis:", bold: true })] }),
        createStyledTable([
          new TableRow({
            children: [createCell("Metric", true), createCell("Score", true)],
            tableHeader: true,
          }),
          new TableRow({
            children: [createCell("Current Score"), createCell(String(currentScore))],
          }),
          new TableRow({
            children: [createCell("Basic Compliance Target"), createCell("3")],
          }),
          new TableRow({
            children: [createCell("Gold Standard Target"), createCell("5")],
          }),
          new TableRow({
            children: [createCell("Gap to Basic Compliance"), createCell(String(gapToBasic))],
          }),
          new TableRow({
            children: [createCell("Gap to Gold Standard"), createCell(String(gapToGold))],
          }),
        ]),
        new Paragraph({ text: "" }),
        new Paragraph({ children: [new TextRun({ text: "Associated Evidence:", bold: true })] }),
        ...(gap.evidence.length > 0
          ? gap.evidence.flatMap((evi: Evidence) => [
              createBullet(`Type: ${evi.type.charAt(0).toUpperCase() + evi.type.slice(1)}`, 1),
              createBullet(`Content: ${evi.content}`, 1),
              createBullet(`Added: ${format(new Date(evi.uploadedAt), "dd MMM yyyy, HH:mm")}`, 1),
              new Paragraph(""),
            ])
          : [createParagraph("No specific evidence provided.")]),
        new Paragraph({ text: "" }),
        new Paragraph({ children: [new TextRun({ text: "Best Practice:", bold: true })] }),
        createParagraph(gap.bestPractice?.description || "N/A"),
        new Paragraph({ text: "" }),
        new Paragraph({ children: [new TextRun({ text: "Implementation Steps:", bold: true })] }),
        ...(gap.bestPractice?.suggestedActions?.map((action) => createBullet(action)) || [
          createParagraph("No specific actions suggested. Review best practice for guidance."),
        ]),
        new Paragraph({
          children: [
            new TextRun({ text: "Reference: ", bold: true }),
            new TextRun({
              text: gap.bestPractice?.link || "No link available",
              style: "Hyperlink",
            }),
          ],
        }),
        new Paragraph({ text: "" }),
      ]
    }),
  ])

  const blob = await Packer.toBlob(doc)
  const today = format(new Date(), "yyyyMMdd")
  const projectName = sanitizeFilename(project.name)
  const refNumber = project.clientReferenceNumber ? sanitizeFilename(project.clientReferenceNumber) : "NO-REF"
  const fileName = `Telana_${today}_${projectName}_${refNumber}_Technical_Guide.docx`
  saveAs(blob, fileName)
}

// --- Data Helper Functions ---
type HighPriorityArea = Question & { standardName: string; category: string }

const getHighPriorityAreas = (project: Project): HighPriorityArea[] => {
  const areas: HighPriorityArea[] = []
  project.standards.forEach((std) => {
    std.questions.forEach((q) => {
      if (q.ragStatus === "red" || q.ragStatus === "amber") {
        areas.push({ ...q, standardName: std.name, category: q.category })
      }
    })
  })
  return areas.sort((a, b) => (a.ragStatus === "red" && b.ragStatus !== "red" ? -1 : 1))
}

const getAllGaps = (project: Project): HighPriorityArea[] => {
  const gaps: HighPriorityArea[] = []
  project.standards.forEach((std) => {
    std.questions.forEach((q) => {
      if (q.ragStatus === "red" || q.ragStatus === "amber") {
        gaps.push({ ...q, standardName: std.name, category: q.category })
      }
    })
  })
  return gaps.sort((a, b) => {
    if (a.ragStatus === "red" && b.ragStatus !== "red") return -1
    if (a.ragStatus !== "red" && b.ragStatus === "red") return 1
    if (a.ragStatus === "amber" && b.ragStatus !== "amber") return -1
    if (a.ragStatus !== "amber" && b.ragStatus === "amber") return 1
    return 0
  })
}
